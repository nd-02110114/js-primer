
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>クラス · JavaScript Primer #jsprimer</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="JavaScriptにおけるクラスの定義方法や継承方法を紹介します。プロトタイプベースの言語であるJavaScriptがどのように継承などを実現しているのかを紹介します。">
        <meta name="generator" content="HonKit 3.6.20">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

         
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../error-try-catch/" />
    
    
    <link rel="prev" href="../function-this/" />
    

    <link rel="canonical" href="https://jsprimer.net/basic/class/">

<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo" />
<style>
    /*
     * Disable antialias
     */
    * {
        -webkit-font-smoothing: initial !important
    }

    body {
        text-rendering: initial !important;
        font-smoothing: initial !important;
    }

    /* deny access chapter */
    .summary li.chapter>span {
        cursor: not-allowed;
        opacity: .3;
    }

    /* console ui */

    .mirror-console-attach-button-wrapper {
        margin-top: -1.275em;
        margin-bottom: 1.275em
    }

    .mirror-console-wrapper {
        margin-top: 1.275em;
        margin-bottom: 1.275em
    }

    /* file name for codeblock */
    .code-filename {
        background-color: #eee;
        display: inline-block;
        padding: 2px 8px;
        line-height: inherit;
        margin-bottom: 0px !important;
    }
    /* Markdown */
    .markdown-section sup, .markdown-section sub {
        font-size: 75%;
    }

    .book_footer{
        text-align: center;
        color: #000000;
        background: #ddd;
        font-size: 16px;
        margin-top: 16px;
        padding: 16px;
    }

    /* github-issue-feedback */
    .gitbook-plugin-github-issue-feedback {
        background-color: #333;
        color: #fff;
        opacity: 0.8;
        padding: 4px;
        margin-right: 24px;
        margin-bottom: 4px;
        border-radius: 6px;
    }

    .gitbook-plugin-github-issue-feedback:hover {
        opacity: 1;
    }

    /* Hide footer on mobile */
    /* Use navigation width */
    @media (max-width: 1240px) {
        .book_footer {
            display: none;
        }
    }

    .navigation {
        min-width: 50px;
    }
</style>
<meta name="theme-color" content="#ffffff">
<link rel="manifest" href="../../manifest.json">
<script>
    if ("serviceWorker" in navigator) {
        const isLocalhost = Boolean(
            // preview
            /netlify.com/.test(window.location.hostname) ||
            // local
            window.location.hostname === "localhost" ||
            // [::1] is the IPv6 localhost address.
            window.location.hostname === "[::1]" ||
            // 127.0.0.1/8 is considered localhost for IPv4.
            window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
        );
        if (!isLocalhost) {
            window.addEventListener("load", () => {
                navigator.serviceWorker.register("../../sw.js");
            });
        }
    }
</script>

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    この書籍について
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../intro/">
            
                <a href="../../intro/">
            
                    
                    はじめに
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../intro/authors/">
            
                <a href="../../intro/authors/">
            
                    
                    著者紹介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../intro/preparation/">
            
                <a href="../../intro/preparation/">
            
                    
                    読み始める前の事前準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../../intro/feedback/">
            
                <a href="../../intro/feedback/">
            
                    
                    文章の間違いに気づいたら
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    第一部: 基本文法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../introduction/">
            
                <a href="../introduction/">
            
                    
                    JavaScriptとは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../comments/">
            
                <a href="../comments/">
            
                    
                    コメント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../variables/">
            
                <a href="../variables/">
            
                    
                    変数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../read-eval-print/">
            
                <a href="../read-eval-print/">
            
                    
                    値の評価と表示
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../data-type/">
            
                <a href="../data-type/">
            
                    
                    データ型とリテラル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../operator/">
            
                <a href="../operator/">
            
                    
                    演算子
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../implicit-coercion/">
            
                <a href="../implicit-coercion/">
            
                    
                    暗黙的な型変換
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../function-declaration/">
            
                <a href="../function-declaration/">
            
                    
                    関数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../statement-expression/">
            
                <a href="../statement-expression/">
            
                    
                    文と式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../condition/">
            
                <a href="../condition/">
            
                    
                    条件分岐
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../loop/">
            
                <a href="../loop/">
            
                    
                    ループと反復処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../object/">
            
                <a href="../object/">
            
                    
                    オブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../prototype-object/">
            
                <a href="../prototype-object/">
            
                    
                    プロトタイプオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.14" data-path="../array/">
            
                <a href="../array/">
            
                    
                    配列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.15" data-path="../string/">
            
                <a href="../string/">
            
                    
                    文字列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.16" data-path="../string-unicode/">
            
                <a href="../string-unicode/">
            
                    
                    文字列とUnicode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.17" data-path="../wrapper-object/">
            
                <a href="../wrapper-object/">
            
                    
                    ラッパーオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.18" data-path="../function-scope/">
            
                <a href="../function-scope/">
            
                    
                    関数とスコープ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.19" data-path="../function-this/">
            
                <a href="../function-this/">
            
                    
                    関数とthis
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.20" data-path="./">
            
                <a href="./">
            
                    
                    クラス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.21" data-path="../error-try-catch/">
            
                <a href="../error-try-catch/">
            
                    
                    例外処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.22" data-path="../async/">
            
                <a href="../async/">
            
                    
                    非同期処理:コールバック/Promise/Async Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.23" data-path="../map-and-set/">
            
                <a href="../map-and-set/">
            
                    
                    Map/Set
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.24" data-path="../json/">
            
                <a href="../json/">
            
                    
                    JSON
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.25" data-path="../date/">
            
                <a href="../date/">
            
                    
                    Date
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.26" data-path="../math/">
            
                <a href="../math/">
            
                    
                    Math
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.27" data-path="../module/">
            
                <a href="../module/">
            
                    
                    ECMAScriptモジュール
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.28" data-path="../ecmascript/">
            
                <a href="../ecmascript/">
            
                    
                    ECMAScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.29" data-path="../other-parts/">
            
                <a href="../other-parts/">
            
                    
                    第一部: おわりに
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../use-case/">
            
                <a href="../../use-case/">
            
                    
                    第二部: 応用編（ユースケース）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../use-case/setup-local-env/">
            
                <a href="../../use-case/setup-local-env/">
            
                    
                    アプリケーション開発の準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../use-case/ajaxapp/">
            
                <a href="../../use-case/ajaxapp/">
            
                    
                    Ajax通信
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../use-case/ajaxapp/entrypoint/">
            
                <a href="../../use-case/ajaxapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../use-case/ajaxapp/http/">
            
                <a href="../../use-case/ajaxapp/http/">
            
                    
                    HTTP通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../use-case/ajaxapp/display/">
            
                <a href="../../use-case/ajaxapp/display/">
            
                    
                    データを表示する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../use-case/ajaxapp/promise/">
            
                <a href="../../use-case/ajaxapp/promise/">
            
                    
                    Promiseを活用する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../use-case/nodecli/">
            
                <a href="../../use-case/nodecli/">
            
                    
                    Node.jsでCLIアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="../../use-case/nodecli/helloworld/">
            
                <a href="../../use-case/nodecli/helloworld/">
            
                    
                    Node.jsでHello World
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="../../use-case/nodecli/argument-parse/">
            
                <a href="../../use-case/nodecli/argument-parse/">
            
                    
                    コマンドライン引数を処理する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.3" data-path="../../use-case/nodecli/read-file/">
            
                <a href="../../use-case/nodecli/read-file/">
            
                    
                    ファイルを読み込む
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.4" data-path="../../use-case/nodecli/md-to-html/">
            
                <a href="../../use-case/nodecli/md-to-html/">
            
                    
                    MarkdownをHTMLに変換する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.5" data-path="../../use-case/nodecli/refactor-and-unittest/">
            
                <a href="../../use-case/nodecli/refactor-and-unittest/">
            
                    
                    ユニットテストを記述する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../use-case/todoapp/">
            
                <a href="../../use-case/todoapp/">
            
                    
                    Todoアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../use-case/todoapp/entrypoint/">
            
                <a href="../../use-case/todoapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="../../use-case/todoapp/app-structure/">
            
                <a href="../../use-case/todoapp/app-structure/">
            
                    
                    アプリの構成要素
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="../../use-case/todoapp/form-event/">
            
                <a href="../../use-case/todoapp/form-event/">
            
                    
                    Todoアイテムの追加を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="../../use-case/todoapp/event-model/">
            
                <a href="../../use-case/todoapp/event-model/">
            
                    
                    イベントとモデル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.5" data-path="../../use-case/todoapp/update-delete/">
            
                <a href="../../use-case/todoapp/update-delete/">
            
                    
                    Todoアイテムの更新と削除を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.6" data-path="../../use-case/todoapp/final/">
            
                <a href="../../use-case/todoapp/final/">
            
                    
                    Todoアプリのリファクタリング
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../appendix/links/">
            
                <a href="../../appendix/links/">
            
                    
                    付録: 参考リンク集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../cheatsheet/">
            
                <a href="../../cheatsheet/">
            
                    
                    付録: JavaScriptチートシート
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../outro/">
            
                <a href="../../outro/">
            
                    
                    おわりに
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                 
                    

<!-- Header -->
<meta name="keywords" content="JavaScript,入門,入門書,チュートリアル,書籍,本,無料,Node.js,ブラウザ"/>
<link rel="author" href="https://www.hatena.ne.jp/efcl/"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<style>
    .book-header {
        display: flex;
        flex-direction: row;
        background-color: #333;
    }

    /* link color */
    .book-header a {
        color: #fff;
    }

    /* hover color */
    .book-header .btn:hover, .book-header .btn:focus, .book-header a:focus, .book-header a:hover {
        color: hsla(0, 0%, 100%, 0.75) !important;
    }

    /* Mobile header fixed */
    @media (max-width: 768px) {
        /* Headerを固定する */
        .book-header {
            position: fixed;
            width: 100%;
        }

        /* Icon only */
        .book-header-title-img {
            margin: auto 18px auto 0 !important;
        }

        .book-header-title-h {
            display: none;
        }

        /* Header分のズレを入れる */
        .page-wrapper {
            padding-top: 60px;
        }

        /* github-issue-feedbackを非表示にする */
        .gitbook-plugin-github-issue-feedback {
            display: none;
        }
    }

    /* Dynamic created by GitBook*/
    .btn.pull-left.js-toolbar-action {
        order: 1;
    }

    .book-header-title {
        order: 2;
        display: inline-flex;
        flex-direction: row;
        color: #fff;
    }

    .book-header-title:hover {
        color: hsla(0, 0%, 100%, 0.75);
    }

    .book-header-title-img {
        width: 32px;
        height: 32px;
        padding: 0;
        margin: auto 10px auto 0;
    }

    .book-header-title-h {
        font-size: 20px;
        margin: auto;
        padding: 0;
    }

    .header-center {
        order: 3;
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        /* self */
        flex-grow: 1;
        flex-shrink: 0;
        flex-basis: auto;
    }

    .header-right {
        order: 4;
        display: inline-flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        /* icon size */
        font-size: 24px;
    }

    .amazon-link, .github-link {
        color: #fff;
        /* Padding and make Vertical */
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-left: 4px;
        padding-right: 4px;
    }

    /* Desktop */
    @media (min-width: 768px) {
        .header-center {
            align-items: center;
        }

        .header-right {
            margin-right: 24px;
        }
    }

    /* DocSearch */
    @media (max-width: 768px) {
        .algolia-autocomplete .ds-dropdown-menu {
            max-width: calc(100vw - 32px) !important;
            min-width: calc(100vw - 32px) !important;
            width: calc(100vw - 32px) !important;
            /* negative margin
              This is absolute element
              */
            margin-left: -32px !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content {
            width: 100% !important;
            padding-left: 0 !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content:before {
            display: none !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column {
            display: none !important;
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu {
            right: inherit !important
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu::before {
            right: 50%;
        }

        .sbx-custom {
            width: 92px !important;
            padding: initial !important;
        }

        .amazon-link {
            display: none;
        }
    }

    /* SearchBox */
    .searchbarWrapper {
        height: 50px;
    }


    .sbx-custom {
        display: inline-block;
        position: relative;
        min-width: 150px;
        width: 300px;
        max-width: 300px;
        height: 33px;
        white-space: nowrap;
        box-sizing: border-box;
        font-size: 14px;
    }

    .sbx-custom__wrapper {
        width: 100%;
        height: 100%;
    }

    .sbx-custom__input {
        display: inline-block;
        -webkit-transition: box-shadow .4s ease, background .4s ease;
        transition: box-shadow .4s ease, background .4s ease;
        border: 0;
        border-radius: 5px;
        box-shadow: inset 0 0 0 2px #CCCCCC;
        background: #FFFFFF;
        padding: 0 27px 0 33px;
        width: 100%;
        height: 100%;
        vertical-align: middle;
        white-space: normal;
        font-size: inherit;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    .sbx-custom__input::-webkit-search-decoration, .sbx-custom__input::-webkit-search-cancel-button, .sbx-custom__input::-webkit-search-results-button, .sbx-custom__input::-webkit-search-results-decoration {
        display: none;
    }

    .sbx-custom__input:hover {
        box-shadow: inset 0 0 0 2px #b3b3b3;
    }

    .sbx-custom__input:focus, .sbx-custom__input:active {
        outline: 0;
        box-shadow: inset 0 0 0 2px #4B54DE;
        background: #FFFFFF;
    }

    .sbx-custom__input::-webkit-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::-moz-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input:-ms-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__submit {
        position: absolute;
        top: 0;
        right: inherit;
        left: 0;
        margin: 0;
        border: 0;
        border-radius: 4px 0 0 4px;
        background-color: rgba(255, 255, 255, 0);
        padding: 0;
        width: 33px;
        height: 100%;
        vertical-align: middle;
        text-align: center;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .sbx-custom__submit::before {
        display: inline-block;
        margin-right: -4px;
        height: 100%;
        vertical-align: middle;
        content: '';
    }

    .sbx-custom__submit:hover, .sbx-custom__submit:active {
        cursor: pointer;
    }

    .sbx-custom__submit:focus {
        outline: 0;
    }

    .sbx-custom__submit svg {
        width: 17px;
        height: 17px;
        vertical-align: middle;
        fill: #3A33D1;
    }

    .sbx-custom__reset {
        display: none;
        position: absolute;
        top: 4px;
        right: 4px;
        margin: 0;
        border: 0;
        background: none;
        cursor: pointer;
        padding: 0;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        fill: rgba(0, 0, 0, 0.5);
    }

    .sbx-custom__reset:focus {
        outline: 0;
    }

    .sbx-custom__reset svg {
        display: block;
        margin: 4px;
        width: 17px;
        height: 17px;
    }

    .sbx-custom__input:valid ~ .sbx-custom__reset {
        display: block;
        -webkit-animation-name: sbx-reset-in;
        animation-name: sbx-reset-in;
        -webkit-animation-duration: .15s;
        animation-duration: .15s;
    }

    @-webkit-keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }

    @keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }
</style>
<div class="book-header" role="navigation">
    
    <a class="book-header-title" href="../..">
        <img class="book-header-title-img" alt="JavaScript Primer"
             src="../../gitbook/icons/icon-128x128.png"/>
        <h2 class="book-header-title-h" title="JavaScript Primer - 迷わないための入門書">JavaScript Primer</h2>
    </a>
    <div class="searchbarWrapper header-center">
        <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-search-8" viewBox="0 0 40 40">
                <path d="M16 32c8.835 0 16-7.165 16-16 0-8.837-7.165-16-16-16C7.162 0 0 7.163 0 16c0 8.835 7.163 16 16 16zm0-5.76c5.654 0 10.24-4.586 10.24-10.24 0-5.656-4.586-10.24-10.24-10.24-5.656 0-10.24 4.584-10.24 10.24 0 5.654 4.584 10.24 10.24 10.24zM28.156 32.8c-1.282-1.282-1.278-3.363.002-4.643 1.282-1.284 3.365-1.28 4.642-.003l6.238 6.238c1.282 1.282 1.278 3.363-.002 4.643-1.283 1.283-3.366 1.28-4.643.002l-6.238-6.238z"
                      fill-rule="evenodd"></path>
            </symbol>
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-clear-5" viewBox="0 0 20 20">
                <path d="M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10zm1.35-10.123l3.567 3.568-1.225 1.226-3.57-3.568-3.567 3.57-1.226-1.227 3.568-3.568-3.57-3.57 1.227-1.224 3.568 3.568 3.57-3.567 1.224 1.225-3.568 3.57zM10 18.272c4.568 0 8.272-3.704 8.272-8.272S14.568 1.728 10 1.728 1.728 5.432 1.728 10 5.432 18.272 10 18.272z"
                      fill-rule="evenodd"></path>
            </symbol>
        </svg>

        <form novalidate="novalidate" onsubmit="return false;" class="searchbox sbx-custom">
            <div role="search" class="sbx-custom__wrapper">
                <input name="search" placeholder="Search words" autocomplete="off" required="required"
                       class="sbx-custom__input" type="search">
                <button type="submit" title="Submit your search query." class="sbx-custom__submit">
                    <svg role="img" aria-label="Search">
                        <use xlink:href="#sbx-icon-search-8"></use>
                    </svg>
                </button>
                <button type="reset" title="Clear the search query." class="sbx-custom__reset">
                    <svg role="img" aria-label="Reset">
                        <use xlink:href="#sbx-icon-clear-5"></use>
                    </svg>
                </button>
            </div>
        </form>
    </div>
    <div class="header-right">
        <!-- Icon: https://www.iconfinder.com/iconsets/circle-payment -->
        <a class="amazon-link" title="Amazon: JavaScript Primer 迷わないための入門書"
           href="https://www.amazon.co.jp/dp/4048930737/" target="_blank"><img
                width="22"
                height="22"
                style="margin: 1px;"
                src="../../gitbook/icons/amazon-icon.png" alt=""></a>
        <a class="github-link" title="GitHub: asciidwango/js-primer" href="https://github.com/asciidwango/js-primer"
           target="_blank"><i
                class="fa fa-github fa-fw"></i></a>
    </div>
</div>

<script type="text/javascript">
    document.querySelector(".searchbox [type=\"reset\"]").addEventListener("click", function() {
        this.parentNode.querySelector("input").focus();
    });
</script>
<script>
    var search = docsearch({
        apiKey: "fd28ebaba94be0c39fb9fa1b2fed4f23", // use a SEARCH-ONLY api key here
        indexName: "asciidwango",
        inputSelector: ".sbx-custom__input",
        debug: false // set to `true` if you want to inspect the dropdown menu's CSS
    });
</script>
<script>
    window.addEventListener("DOMContentLoaded", function () {
        gitbook.events.on("page.change", function () {
            setTimeout(() => console.clear(), 1000);
        });
    });
</script>
<script type="text/javascript">
    (function(){var t,e,n,r,a;for(t=function(){var t;return t=[],function(){var e,n,r,a;for(n=["init","start","stop","user","track","action","event","goal","chat","buy","page","view","admin","group","alias","ready","link","form","click","submit","cmd","emit","on","send","css","js","style","option","get","set","collection"],e=function(e){return function(){return t.push([e].concat(Array.prototype.slice.call(arguments,0)))}},r=0,a=[];r<n.length;)t[n[r]]=e(n[r]),a.push(r++);return a}(),t.init=function(e,n){var r,a;return t.api_key=e,t.options=n||{},a=document.createElement("script"),a.type="text/javascript",a.async=!0,a.charset="utf-8",a.src=t.options.tracker_url||"https://static.karte.io/libs/tracker.js",r=document.getElementsByTagName("script")[0],r.parentNode.insertBefore(a,r)},t},r=window.karte_tracker_names||["tracker"],e=0,n=r.length;n>e;e++)a=r[e],window[a]||(window[a]=t());tracker.init("a2d22604ec1d1c6d9d53d9d3eb87961d", { spa_mode: { reset_past_actions: true, close_actions: true }})}).call(this);
    window.addEventListener("DOMContentLoaded", function(){
        gitbook.events.on("page.change", function() {
            tracker.view();
        });
    });
</script>





                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="class"><a name="class" class="plugin-anchor" href="#class"><i class="fa fa-link" aria-hidden="true"></i></a>クラス </h1>
<p>「クラス」と一言にいってもさまざまであるため、ここでは<strong>構造</strong>、<strong>動作</strong>、<strong>状態</strong>を定義できるものを指すことにします。
また、この章では概念を示す場合は<strong>クラス</strong>と呼び、クラスに関する構文（記述するコード）のことを<code>class</code>構文と呼びます。</p>
<p><strong>クラス</strong>とは<strong>動作</strong>や<strong>状態</strong>を定義した<strong>構造</strong>です。
クラスからはインスタンスと呼ばれるオブジェクトを作成でき、インスタンスはクラスに定義した<strong>動作</strong>を継承し、<strong>状態</strong>は動作によって変化します。
とても抽象的なことに思えますが、これは今までオブジェクトや関数を使って表現してきたものです。
JavaScriptではES2015より前までは<code>class</code>構文はなく、関数を使ってクラスのようなものを表現して扱っていました。</p>
<p>ES2015でクラスを表現するための<code>class</code>構文が導入されましたが、この<code>class</code>構文で定義したクラスは関数オブジェクトの一種です。
<code>class</code>構文ではプロトタイプベースの継承の仕組みを使って関数でクラスを表現しています。
そのため、<code>class</code>構文はクラスを作るための関数定義や継承をパターン化した書き方と言えます。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>また、関数の定義方法として関数宣言文と関数式があるように、クラスにもクラス宣言文とクラス式があります。
このように関数とクラスは似ている部分が多いです。</p>
<p>この章では、<code>class</code>構文でのクラスの定義や継承、クラスの性質について学んでいきます。</p>
<h2 id="class-declaration"><a name="class-declaration" class="plugin-anchor" href="#class-declaration"><i class="fa fa-link" aria-hidden="true"></i></a>クラスの定義 </h2>
<p>クラスを定義するには<code>class</code>構文を使います。
クラスの定義方法にはクラス宣言文とクラス式があります。</p>
<p>まずは、クラス宣言文によるクラスの定義方法を見ていきます。</p>
<p>クラス宣言文では<code>class</code>キーワードを使い、<code>class クラス名{ }</code>のようにクラスの<strong>構造</strong>を定義できます。</p>
<p>クラスは必ずコンストラクタを持ち、<code>constructor</code>という名前のメソッドとして定義します。
コンストラクタとは、そのクラスからインスタンスを作成する際にインスタンスに関する<strong>状態</strong>の初期化を行うメソッドです。
<code>constructor</code>メソッドに定義した処理は、クラスをインスタンス化したときに自動的に呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// コンストラクタ関数の処理</span>
        <span class="hljs-comment">// インスタンス化されるときに自動的に呼び出される</span>
    }
}
</code></pre>
<p>もうひとつの定義方法であるクラス式は、クラスを値として定義する方法です。
クラス式ではクラス名を省略できます。これは関数式における匿名関数と同じです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> MyClass = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
};

<span class="hljs-keyword">const</span> AnonymousClass = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
};
</code></pre>
<p>コンストラクタ関数内で、何も処理がない場合はコンストラクタの記述を省略できます。
省略した場合でも自動的に空のコンストラクタが定義されるため、クラスにはコンストラクタが必ず存在します。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassA</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// コンストラクタの処理が必要なら書く</span>
    }
}
<span class="hljs-comment">// コンストラクタの処理が不要な場合は省略できる</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassB</span> </span>{

}
</code></pre>
<h2 id="class-instance"><a name="class-instance" class="plugin-anchor" href="#class-instance"><i class="fa fa-link" aria-hidden="true"></i></a>クラスのインスタンス化 </h2>
<p>クラスは<code>new</code>演算子でインスタンスであるオブジェクトを作成できます。
<code>class</code>構文で定義したクラスからインスタンスを作成することを<strong>インスタンス化</strong>と呼びます。
あるインスタンスが指定したクラスから作成されたものかを判定するには<code>instanceof</code>演算子が利用できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
}
<span class="hljs-comment">// `MyClass`をインスタンス化する</span>
<span class="hljs-keyword">const</span> myClass = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// 毎回新しいインスタンス(オブジェクト)を作成する</span>
<span class="hljs-keyword">const</span> myClassAnother = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// それぞれのインスタンスは異なるオブジェクト</span>
<span class="hljs-built_in">console</span>.log(myClass === myClassAnother); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// クラスのインスタンスかどうかは`instanceof`演算子で判定できる</span>
<span class="hljs-built_in">console</span>.log(myClass <span class="hljs-keyword">instanceof</span> MyClass); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-built_in">console</span>.log(myClassAnother <span class="hljs-keyword">instanceof</span> MyClass); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>このままでは何も処理がない空のクラスなので、値を持ったクラスを定義してみましょう。</p>
<p>クラスではインスタンスの初期化処理をコンストラクタ関数で行います。
コンストラクタ関数は<code>new</code>演算子でインスタンス化する際に自動的に呼び出されます。
コンストラクタ関数内での<code>this</code>はこれから新しく作るインスタンスオブジェクトとなります。</p>
<p>次のコードでは、<code>x</code>座標と<code>y</code>座標の値を持つ<code>Point</code>というクラスを定義しています。
コンストラクタ関数（<code>constructor</code>）の中でインスタンスオブジェクト（<code>this</code>）の<code>x</code>と<code>y</code>プロパティに値を代入して初期化しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
    <span class="hljs-comment">// コンストラクタ関数の仮引数として`x`と`y`を定義</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> {
        <span class="hljs-comment">// コンストラクタ関数における`this`はインスタンスを示すオブジェクト</span>
        <span class="hljs-comment">// インスタンスの`x`と`y`プロパティにそれぞれ値を設定する</span>
        <span class="hljs-built_in">this</span>.x = x;
        <span class="hljs-built_in">this</span>.y = y;
    }
}
</code></pre>
<p>この<code>Point</code>クラスのインスタンスを作成するには<code>new</code>演算子を使います。
<code>new</code>演算子には関数呼び出しと同じように引数を渡すことができます。
<code>new</code>演算子の引数はクラスの<code>constructor</code>メソッド（コンストラクタ関数）の仮引数に渡されます。
そして、コンストラクタの中ではインスタンスオブジェクト（<code>this</code>）の初期化処理を行います。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
    <span class="hljs-comment">// 2. コンストラクタ関数の仮引数として`x`には`3`、`y`には`4`が渡る</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> {
        <span class="hljs-comment">// 3. インスタンス(`this`)の`x`と`y`プロパティにそれぞれ値を設定する</span>
        <span class="hljs-built_in">this</span>.x = x;
        <span class="hljs-built_in">this</span>.y = y;
        <span class="hljs-comment">// コンストラクタではreturn文は書かない</span>
    }
}

<span class="hljs-comment">// 1. コンストラクタを`new`演算子で引数とともに呼び出す</span>
<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-comment">// 4. `Point`のインスタンスである`point`の`x`と`y`プロパティには初期化された値が入る</span>
<span class="hljs-built_in">console</span>.log(point.x); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-built_in">console</span>.log(point.y); <span class="hljs-comment">// =&gt; 4</span>
</code></pre>
<p>このようにクラスからインスタンスを作成するには必ず<code>new</code>演算子を使います。</p>
<p>一方、クラスは通常の関数として呼ぶことができません。
これは、クラスのコンストラクタはインスタンス（<code>this</code>）を初期化する場所であり、通常の関数とは役割が異なるためです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> { }
}
<span class="hljs-comment">// クラスのコンストラクタ関数として呼び出すことはできない</span>
MyClass(); <span class="hljs-comment">// =&gt; TypeError: class constructors must be invoked with |new|</span>
</code></pre>
<p>コンストラクタは初期化処理を書く場所であるため、<code>return</code>文で値を返すべきではありません。
JavaScriptでは、コンストラクタ関数が任意のオブジェクトを返すことが可能ですが、行うべきではありません。
なぜなら、コンストラクタは<code>new</code>演算子で呼び出し、その評価結果はクラスのインスタンスを期待するのが一般的であるためです。</p>
<p>次のコードのようにコンストラクタで返した値が<code>new</code>演算子で呼び出した際の返り値となります。
このような書き方は混乱を生むため避けるべきです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 非推奨の例: コンストラクタで値を返すべきではない</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> {
        <span class="hljs-comment">// `this`の代わりにただのオブジェクトを返せる</span>
        <span class="hljs-keyword">return</span> { x, y };
    }
}

<span class="hljs-comment">// `new`演算子の結果はコンストラクタ関数が返したただのオブジェクト</span>
<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(point); <span class="hljs-comment">// =&gt; { x: 3, y: 4 }</span>
<span class="hljs-comment">// Pointクラスのインスタンスではない</span>
<span class="hljs-built_in">console</span>.log(point <span class="hljs-keyword">instanceof</span> Point); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<h3 id="class-name-start-upper-case"><a name="class-name-start-upper-case" class="plugin-anchor" href="#class-name-start-upper-case"><i class="fa fa-link" aria-hidden="true"></i></a>[Note] クラス名は大文字ではじめる </h3>
<p>JavaScriptでは慣習としてクラス名には大文字ではじまる名前をつけます。
これは、変数名にキャメルケースを使う慣習があるのと同じで、名前自体に特別なルールがあるわけではありません。
クラス名を大文字にしておき、そのインスタンスは小文字で開始すれば名前が被らないという合理的な理由で好まれています。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thing</span> </span>{}
<span class="hljs-keyword">const</span> thing = <span class="hljs-keyword">new</span> Thing();
</code></pre>
<h3 id="class-vs-function"><a name="class-vs-function" class="plugin-anchor" href="#class-vs-function"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] <code>class</code>構文と関数でのクラスの違い </h3>
<p>ES2015より前はこれらのクラスを<code>class</code>構文ではなく、関数で表現していました。
その表現方法は人によってさまざまで、これも<code>class</code>構文という統一した記法が導入された理由の1つです。</p>
<p>次のコードは、関数でクラスを実装した1つの例です。
この関数でのクラス表現は、継承の仕組みなどは省かれていますが、<code>class</code>構文とよく似ています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// コンストラクタ関数</span>
<span class="hljs-keyword">const</span> Point = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PointConstructor</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-comment">// インスタンスの初期化処理</span>
    <span class="hljs-built_in">this</span>.x = x;
    <span class="hljs-built_in">this</span>.y = y;
};

<span class="hljs-comment">// `new`演算子でコンストラクタ関数から新しいインスタンスを作成</span>
<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
</code></pre>
<p>大きな違いとして、<code>class</code>構文で定義したクラスは関数として呼び出すことができません。
クラスは<code>new</code>演算子でインスタンス化して使うものなので、これはクラスの誤用を防ぐ仕様です。
一方、関数でのクラス表現はただの関数なので、当然関数として呼び出せます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 関数でのクラス表現</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClassLike</span>(<span class="hljs-params"></span>) </span>{
}
<span class="hljs-comment">// 関数なので関数として呼び出せる</span>
MyClassLike();

<span class="hljs-comment">// `class`構文でのクラス</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
}
<span class="hljs-comment">// クラスは関数として呼び出すと例外が発生する</span>
MyClass(); <span class="hljs-comment">// =&gt; TypeError: class constructors must be invoked with |new|</span>
</code></pre>
<p>このように、関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。
このような問題を避けるためにもクラスは<code>class</code>構文を使って実装します。</p>
<h2 id="class-prototype-method-definition"><a name="class-prototype-method-definition" class="plugin-anchor" href="#class-prototype-method-definition"><i class="fa fa-link" aria-hidden="true"></i></a>クラスのプロトタイプメソッドの定義 </h2>
<p>クラスの<strong>動作</strong>はメソッドによって定義できます。
<code>constructor</code>メソッドは初期化時に呼ばれる特殊なメソッドですが、<code>class</code>構文ではクラスに対して自由にメソッドを定義できます。
このクラスに定義したメソッドは作成したインスタンスが持つ動作となります。</p>
<p>次のように<code>class</code>構文ではクラスに対してメソッドを定義できます。
メソッドの中からクラスのインスタンスを参照するには、<code>constructor</code>メソッドと同じく<code>this</code>を使います。
このクラスのメソッドにおける<code>this</code>は「<a href="../function-this/">関数とthis</a>」の章で学んだメソッドと同じくベースオブジェクトを参照します。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    メソッド() {
        <span class="hljs-comment">// ここでの`this`はベースオブジェクトを参照</span>
    }
}

<span class="hljs-keyword">const</span> インスタンス = <span class="hljs-keyword">new</span> クラス();
<span class="hljs-comment">// メソッド呼び出しのベースオブジェクト(`this`)は`インスタンス`となる</span>
インスタンス.メソッド();
</code></pre>
<p>クラスのプロトタイプメソッド定義では、オブジェクトにおけるメソッドとは異なり<code>key : value</code>のように<code>:</code>区切りでメソッドを定義できないことに注意してください。
つまり、次のような書き方は構文エラー（<code>SyntaxError</code>）となります。</p>
<!-- textlint-disable -->
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-comment">// クラスでは次のようにメソッドを定義できない</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
   <span class="hljs-comment">// SyntaxError</span>
   メソッド: <span class="hljs-function">() =&gt;</span> {}
   <span class="hljs-comment">// SyntaxError</span>
   メソッド: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
}
</code></pre>
<!-- textlint-enable -->
<p>このようにクラスに対して定義したメソッドは、クラスの各インスタンスから<strong>共有されるメソッド</strong>となります。
このインスタンス間で共有されるメソッドのことを<strong>プロトタイプメソッド</strong>と呼びます。
また、プロトタイプメソッドはインスタンスから呼び出せるメソッドであるため<strong>インスタンスメソッド</strong>とも呼ばれます。</p>
<p>この書籍では、プロトタイプメソッド（インスタンスメソッド）を<code>クラス#メソッド名</code>のように表記します。</p>
<p>次のコードでは、<code>Counter</code>クラスに<code>increment</code>メソッド（<code>Counter#increment</code>メソッド）を定義しています。
<code>Counter</code>クラスのインスタンスはそれぞれ別々の状態（<code>count</code>プロパティ）を持ちます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">// `increment`メソッドをクラスに定義する</span>
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// `this`は`Counter`のインスタンスを参照する</span>
        <span class="hljs-built_in">this</span>.count++;
    }
}
<span class="hljs-keyword">const</span> counterA = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-keyword">const</span> counterB = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-comment">// `counterA.increment()`のベースオブジェクトは`counterA`インスタンス</span>
counterA.increment();
<span class="hljs-comment">// 各インスタンスの持つプロパティ(状態)は異なる</span>
<span class="hljs-built_in">console</span>.log(counterA.count); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-built_in">console</span>.log(counterB.count); <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<p>また<code>increment</code>メソッドはプロトタイプメソッドとして定義されています。
プロトタイプメソッドは各インスタンス間で共有されます。
そのため、次のように各インスタンスの<code>increment</code>メソッドの参照先は同じとなっていることがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count++;
    }
}
<span class="hljs-keyword">const</span> counterA = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-keyword">const</span> counterB = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-comment">// 各インスタンスオブジェクトのメソッドは共有されている(同じ関数を参照している)</span>
<span class="hljs-built_in">console</span>.log(counterA.increment === counterB.increment); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>プロトタイプメソッドがなぜインスタンス間で共有されているのかは、クラスの継承の仕組みと密接に関係しています。
プロトタイプメソッドの仕組みについては後ほど解説します。</p>
<h3 id="class-instance-method"><a name="class-instance-method" class="plugin-anchor" href="#class-instance-method"><i class="fa fa-link" aria-hidden="true"></i></a>クラスのインスタンスに対してメソッドを定義する </h3>
<p><code>class</code>構文でのメソッド定義はプロトタイプメソッドとなり、インスタンス間で共有されます。</p>
<p>一方、クラスのインスタンスに対して、直接メソッドを定義する方法もあります。
これは、コンストラクタ関数内でインスタンスオブジェクトである<code>this</code>に対してメソッドを定義するだけです。</p>
<p>次のコードでは、<code>Counter</code>クラスのコンストラクタ関数で、インスタンスオブジェクトに<code>increment</code>メソッドを定義しています。
コンストラクタ関数内で<code>this</code>はインスタンスオブジェクトを示すため、<code>this</code>に対してメソッドを定義しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">this</span>.increment = <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// `this`は`constructor`メソッドにおける`this`（インスタンスオブジェクト）を参照する</span>
            <span class="hljs-built_in">this</span>.count++;
        };
    }
}
<span class="hljs-keyword">const</span> counterA = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-keyword">const</span> counterB = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-comment">// `counterA.increment()`のベースオブジェクトは`counterA`インスタンス</span>
counterA.increment();
<span class="hljs-comment">// 各インスタンスの持つプロパティ(状態)は異なる</span>
<span class="hljs-built_in">console</span>.log(counterA.count); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-built_in">console</span>.log(counterB.count); <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<p>この方法で定義した<code>increment</code>メソッドはインスタンスから呼び出せるため、インスタンスメソッドです。
しかし、インスタンスオブジェクトに定義した<code>increment</code>メソッドはプロトタイプメソッドではありません。
インスタンスオブジェクトのメソッドとプロトタイプメソッドには、いくつか異なる点があります。</p>
<p>プロトタイプメソッドは各インスタンスから共有されているため、各インスタンスからのメソッドの参照先が同じでした。
しかし、インスタンスオブジェクトのメソッドは、コンストラクタで毎回同じ挙動の関数（オブジェクト）を新しく定義しています。
そのため、次のように各インスタンスからのメソッドの参照先も異なります。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">this</span>.increment = <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">this</span>.count++;
        };
    }
}
<span class="hljs-keyword">const</span> counterA = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-keyword">const</span> counterB = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-comment">// 各インスタンスオブジェクトのメソッドの参照先は異なる</span>
<span class="hljs-built_in">console</span>.log(counterA.increment !== counterB.increment); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>また、プロトタイプメソッドとは異なり、インスタンスオブジェクトへのメソッド定義はArrow Functionが利用できます。
Arrow Functionには<code>this</code>が静的に決まるという性質があるため、メソッドにおける<code>this</code>の参照先をインスタンスに固定できます。
なぜならArrow Functionで定義した<code>increment</code>メソッドはどのような呼び出し方をしても、必ず<code>constructor</code>における<code>this</code>となるためです（「<a href="../function-this/#arrow-function-callback">Arrow Functionでコールバック関数を扱う</a>」を参照）。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-meta">&quot;use strict&quot;</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrowClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// コンストラクタでの`this`は常にインスタンス</span>
        <span class="hljs-built_in">this</span>.method = <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// Arrow Functionにおける`this`は静的に決まる</span>
            <span class="hljs-comment">// そのため`this`は常にインスタンスを参照する</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        };
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> ArrowClass();
<span class="hljs-keyword">const</span> method = instance.method;
<span class="hljs-comment">// 呼び出し方法（ベースオブジェクト）に依存しないため、`this`がインスタンスを参照する</span>
<span class="hljs-built_in">console</span>.log(method()); <span class="hljs-comment">// =&gt; instance</span>
</code></pre>
<p>一方、プロトタイプメソッドにおける<code>this</code>はメソッド呼び出し時のベースオブジェクトを参照します。
そのためプロトタイプメソッドは呼び出し方によって<code>this</code>の参照先が異なります（「<a href="../function-this/">関数とthis</a>」の章の「<a href="../function-this/#assign-this-function">問題: <code>this</code>を含むメソッドを変数に代入した場合</a>」を参照）。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-meta">&quot;use strict&quot;</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// `this`はベースオブジェクトを参照する</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
    };
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> PrototypeClass();
<span class="hljs-keyword">const</span> method = instance.method;
<span class="hljs-comment">// ベースオブジェクトはundefined</span>
<span class="hljs-built_in">console</span>.log(method()); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>このように、インスタンスに対してArrow Functionでメソッドを定義することで<code>this</code>の参照先を固定化できます。</p>
<h2 id="class-accessor-property"><a name="class-accessor-property" class="plugin-anchor" href="#class-accessor-property"><i class="fa fa-link" aria-hidden="true"></i></a>クラスのアクセッサプロパティの定義 </h2>
<!-- textlint-disable no-js-function-paren -->
<p>クラスに対してメソッドを定義できますが、メソッドは<code>メソッド名()</code>のように呼び出す必要があります。
クラスでは、プロパティの参照（getter）、プロパティへの代入（setter）時に呼び出される特殊なメソッドを定義できます。
このメソッドはプロパティのように振る舞うため<strong>アクセッサプロパティ</strong>と呼ばれます。</p>
<!-- textlint-enable no-js-function-paren -->
<p>次のコードでは、プロパティの参照（getter）、プロパティへの代入（setter）に対するアクセッサプロパティを定義しています。
アクセッサプロパティはメソッド名（プロパティ名）の前に<code>get</code>または<code>set</code>をつけるだけです。
getter（<code>get</code>）には仮引数はありませんが、必ず値を返す必要があります。
setter（<code>set</code>）の仮引数にはプロパティへ代入する値が入りますが、値を返す必要はありません。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    <span class="hljs-comment">// getter</span>
    get プロパティ名() {
        <span class="hljs-keyword">return</span> 値;
    }
    <span class="hljs-comment">// setter</span>
    set プロパティ名(仮引数) {
        <span class="hljs-comment">// setterの処理</span>
    }
}
<span class="hljs-keyword">const</span> インスタンス = <span class="hljs-keyword">new</span> クラス();
インスタンス.プロパティ名; <span class="hljs-comment">// getterが呼び出される</span>
インスタンス.プロパティ名 = 値; <span class="hljs-comment">// setterが呼び出される</span>
</code></pre>
<p>次のコードでは、<code>NumberWrapper</code>クラスの<code>value</code>プロパティをアクセッサプロパティとして定義しています。
<code>value</code>プロパティへアクセスした際にそれぞれ定義したgetterとsetterが呼ばれているのがわかります。
このアクセッサプロパティで実際に読み書きされているのは、<code>NumberWrapper</code>インスタンスの<code>_value</code>プロパティとなります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberWrapper</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> {
        <span class="hljs-built_in">this</span>._value = value;
    }
    <span class="hljs-comment">// `_value`プロパティの値を返すgetter</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title">value</span>() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;getter&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._value;
    }
    <span class="hljs-comment">// `_value`プロパティに値を代入するsetter</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title">value</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setter&quot;</span>);
        <span class="hljs-built_in">this</span>._value = newValue;
    }
}

<span class="hljs-keyword">const</span> numberWrapper = <span class="hljs-keyword">new</span> NumberWrapper(<span class="hljs-number">1</span>);
<span class="hljs-comment">// &quot;getter&quot;とコンソールに表示される</span>
<span class="hljs-built_in">console</span>.log(numberWrapper.value); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-comment">// &quot;setter&quot;とコンソールに表示される</span>
numberWrapper.value = <span class="hljs-number">42</span>;
<span class="hljs-comment">// &quot;getter&quot;とコンソールに表示される</span>
<span class="hljs-built_in">console</span>.log(numberWrapper.value); <span class="hljs-comment">// =&gt; 42</span>
</code></pre>
<!-- Note: インスタンスオブジェクトのアクセッサプロパティ
インスタンスオブジェクトへも定義できるが、メソッドとは異なり意味の違いがでることはないため省略。
またフィールドとして定義することはできないため対比は意味がない。
-->
<h3 id="private-property"><a name="private-property" class="plugin-anchor" href="#private-property"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] プライベートプロパティ </h3>
<p><code>NumberWrapper#value</code>のアクセッサプロパティで実際に読み書きしているのは、<code>_value</code>プロパティです。
このように、外から直接読み書きしてほしくないプロパティを<code>_</code>（アンダーバー）で開始するのはただの習慣であるため、構文としての意味はありません。</p>
<p>現時点（ECMAScript 2020）では、外から原理的に参照できないプライベートプロパティ（hard private）を定義する構文はありません。
しかし、現時点でも<code>WeakSet</code>などを使うことで疑似的なプライベートプロパティを実現できます。
<code>WeakSet</code>については「<a href="../map-and-set/">Map/Set</a>」の章で解説します。</p>
<h3 id="array-like-length"><a name="array-like-length" class="plugin-anchor" href="#array-like-length"><i class="fa fa-link" aria-hidden="true"></i></a><code>Array#length</code>をアクセッサプロパティで再現する </h3>
<p>getterやsetterを利用しないと実現が難しいものとして<code>Array#length</code>プロパティがあります。
<code>Array#length</code>プロパティへ値を代入すると、そのインデックス以降の要素は自動的に削除される仕様になっています。</p>
<p>次のコードでは、配列の要素数（<code>length</code>プロパティ）を小さくすると配列の要素が削除されています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-comment">// 要素数を減らすと、インデックス以降の要素が削除される</span>
array.length = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(array.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2&quot;</span>
<span class="hljs-comment">// 要素数だけを増やしても、配列の中身は空要素が増えるだけ</span>
array.length = <span class="hljs-number">5</span>;
<span class="hljs-built_in">console</span>.log(array.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2, , , &quot;</span>
</code></pre>
<p>この<code>length</code>プロパティの挙動を再現する<code>ArrayLike</code>クラスを実装してみます。
<code>Array#length</code>プロパティは、<code>length</code>プロパティへ値を代入した際に次のようなことを行っています。</p>
<ul>
<li>現在要素数より小さな<strong>要素数</strong>が指定された場合、その<strong>要素数</strong>を変更し、配列の末尾の要素を削除する</li>
<li>現在要素数より大きな<strong>要素数</strong>が指定された場合、その<strong>要素数</strong>だけを変更し、配列の実際の要素はそのままにする</li>
</ul>
<!-- Note:

- 仕様的にもIf newLen ≥ oldLenでは`length`だけを変更している
- <https://tc39.github.io/ecma262/#sec-arraysetlength>

-->
<p><code>ArrayLike#length</code>のsetterで要素の追加や削除を実装することで、配列のような<code>length</code>プロパティを実装できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * 配列のようなlengthを持つクラス
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayLike</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">items = []</span>)</span> {
        <span class="hljs-built_in">this</span>._items = items;
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">items</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._items;
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._items.length;
    }

    <span class="hljs-keyword">set</span> <span class="hljs-title">length</span>(<span class="hljs-params">newLength</span>) {
        <span class="hljs-keyword">const</span> currentItemLength = <span class="hljs-built_in">this</span>.items.length;
        <span class="hljs-comment">// 現在要素数より小さな`newLength`が指定された場合、指定した要素数となるように末尾を削除する</span>
        <span class="hljs-keyword">if</span> (newLength &lt; currentItemLength) {
            <span class="hljs-built_in">this</span>._items = <span class="hljs-built_in">this</span>.items.slice(<span class="hljs-number">0</span>, newLength);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newLength &gt; currentItemLength) {
            <span class="hljs-comment">// 現在要素数より大きな`newLength`が指定された場合、指定した要素数となるように末尾に空要素を追加する</span>
            <span class="hljs-built_in">this</span>._items = <span class="hljs-built_in">this</span>.items.concat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(newLength - currentItemLength));
        }
    }
}

<span class="hljs-keyword">const</span> arrayLike = <span class="hljs-keyword">new</span> ArrayLike([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-comment">// 要素数を減らすとインデックス以降の要素が削除される</span>
arrayLike.length = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(arrayLike.items.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2&quot;</span>
<span class="hljs-comment">// 要素数を増やすと末尾に空要素が追加される</span>
arrayLike.length = <span class="hljs-number">5</span>;
<span class="hljs-built_in">console</span>.log(arrayLike.items.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2, , , &quot;</span>
</code></pre>
<p>このようにアクセッサプロパティでは、プロパティのようでありながら実際にアクセスした際には他のプロパティと連動する動作を実現できます。</p>
<h2 id="static-method"><a name="static-method" class="plugin-anchor" href="#static-method"><i class="fa fa-link" aria-hidden="true"></i></a>静的メソッド </h2>
<p>インスタンスメソッドは、クラスをインスタンス化して利用します。
一方、クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。</p>
<p>静的メソッドの定義方法はメソッド名の前に、<code>static</code>をつけるだけです。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    <span class="hljs-keyword">static</span> メソッド() {
        <span class="hljs-comment">// 静的メソッドの処理</span>
    }
}
<span class="hljs-comment">// 静的メソッドの呼び出し</span>
クラス.メソッド();
</code></pre>
<p>次のコードでは、配列をラップする<code>ArrayWrapper</code>というクラスを定義しています。
<code>ArrayWrapper</code>はコンストラクタの引数として配列を受け取って初期化しています。
このクラスに配列ではなく要素そのものを引数に受け取ってインスタンス化できる<code>ArrayWrapper.of</code>という静的メソッドを定義します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayWrapper</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">array = []</span>)</span> {
        <span class="hljs-built_in">this</span>.array = array;
    }

    <span class="hljs-comment">// rest parametersとして要素を受けつける</span>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">of</span>(<span class="hljs-params">...items</span>)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayWrapper(items);
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.array.length;
    }
}

<span class="hljs-comment">// 配列を引数として渡している</span>
<span class="hljs-keyword">const</span> arrayWrapperA = <span class="hljs-keyword">new</span> ArrayWrapper([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-comment">// 要素を引数として渡している</span>
<span class="hljs-keyword">const</span> arrayWrapperB = ArrayWrapper.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(arrayWrapperA.length); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-built_in">console</span>.log(arrayWrapperB.length); <span class="hljs-comment">// =&gt; 3</span>
</code></pre>
<p>クラスの静的メソッドにおける<code>this</code>は、そのクラス自身を参照します。
そのため、先ほどのコードは<code>new ArrayWrapper</code>の代わりに<code>new this</code>と書くこともできます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayWrapper</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">array = []</span>)</span> {
        <span class="hljs-built_in">this</span>.array = array;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">of</span>(<span class="hljs-params">...items</span>)</span> {
        <span class="hljs-comment">// `this`は`ArrayWrapper`を参照する</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>(items);
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.array.length;
    }
}

<span class="hljs-keyword">const</span> arrayWrapper = ArrayWrapper.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(arrayWrapper.length); <span class="hljs-comment">// =&gt; 3</span>
</code></pre>
<p>このように静的メソッドでの<code>this</code>はクラス自身を参照するため、クラスのインスタンスは参照できません。
そのため静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。</p>
<h2 id="two-instance-method-definition"><a name="two-instance-method-definition" class="plugin-anchor" href="#two-instance-method-definition"><i class="fa fa-link" aria-hidden="true"></i></a>2種類のインスタンスメソッドの定義 </h2>
<p>クラスでは、2種類のインスタンスメソッドの定義方法があります。
<code>class</code>構文を使ったインスタンス間で共有されるプロトタイプメソッドの定義と、
インスタンスオブジェクトに対するメソッドの定義です。</p>
<p>これらの2つの方法を同時に使い、1つのクラスに同じ名前でメソッドを2つ定義した場合はどうなるでしょうか？</p>
<p>次のコードでは、<code>ConflictClass</code>クラスにプロトタイプメソッドとインスタンスに対して同じ<code>method</code>という名前のメソッドを定義しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConflictClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// インスタンスオブジェクトに`method`を定義</span>
        <span class="hljs-built_in">this</span>.method = <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;インスタンスオブジェクトのメソッド&quot;</span>);
        };
    }

    <span class="hljs-comment">// クラスのプロトタイプメソッドとして`method`を定義</span>
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> conflict = <span class="hljs-keyword">new</span> ConflictClass();
conflict.method(); <span class="hljs-comment">// どちらの`method`が呼び出される？</span>
</code></pre>
<p>結論から述べると、この場合はインスタンスオブジェクトに定義した<code>method</code>が呼び出されます。
このとき、インスタンスの<code>method</code>プロパティを<code>delete</code>演算子で削除すると、今度はプロトタイプメソッドの<code>method</code>が呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConflictClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.method = <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;インスタンスオブジェクトのメソッド&quot;</span>);
        };
    }

    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプメソッド&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> conflict = <span class="hljs-keyword">new</span> ConflictClass();
conflict.method(); <span class="hljs-comment">// &quot;インスタンスオブジェクトのメソッド&quot;</span>
<span class="hljs-comment">// インスタンスの`method`プロパティを削除</span>
<span class="hljs-keyword">delete</span> conflict.method;
conflict.method(); <span class="hljs-comment">// &quot;プロトタイプメソッド&quot;</span>
</code></pre>
<p>この実行結果から次のことがわかります。</p>
<ul>
<li>プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている</li>
<li>インスタンスオブジェクトのメソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている</li>
</ul>
<p>どちらも注意深く意識しないと気づきにくいですが、この挙動はJavaScriptの重要な仕組みであるため理解することは重要です。</p>
<p>この挙動は<strong>プロトタイプオブジェクト</strong>と呼ばれる特殊なオブジェクトと<strong>プロトタイプチェーン</strong>と呼ばれる仕組みで成り立っています。
どちらも<strong>プロトタイプ</strong>とついていることからわかるように、2つで1組のような仕組みです。</p>
<p>このセクションでは、<strong>プロトタイプオブジェクト</strong>と<strong>プロトタイプチェーン</strong>とはどのような仕組みなのかを見ていきます。</p>
<h2 id="prototype"><a name="prototype" class="plugin-anchor" href="#prototype"><i class="fa fa-link" aria-hidden="true"></i></a>プロトタイプオブジェクト </h2>
<p><strong>プロトタイプメソッド</strong>と<strong>インスタンスオブジェクトのメソッド</strong>を同時に定義しても、互いのメソッドは上書きされるわけでありません。
なぜなら、プロトタイプメソッドは<strong>プロトタイプオブジェクト</strong>へ、インスタンスオブジェクトのメソッドは<strong>インスタンスオブジェクト</strong>へそれぞれ定義されるためです。</p>
<p>プロトタイプオブジェクトについては「<a href="../prototype-object/">プロトタイプオブジェクト</a>」の章で簡単に紹介していましたが、改めて解説していきます。</p>
<p><strong>プロトタイプオブジェクト</strong>とは、JavaScriptの関数オブジェクトの<code>prototype</code>プロパティに自動的に作成される特殊なオブジェクトです。
クラスも一種の関数オブジェクトであるため、自動的に<code>prototype</code>プロパティにプロトタイプオブジェクトが作成されています。</p>
<p>次のコードでは、関数やクラス自身の<code>prototype</code>プロパティに、プロトタイプオブジェクトが自動的に作成されていることがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
}
<span class="hljs-comment">// `prototype`プロパティにプロトタイプオブジェクトが存在する</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> fn.prototype === <span class="hljs-string">&quot;object&quot;</span>); <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
}
<span class="hljs-comment">// `prototype`プロパティにプロトタイプオブジェクトが存在する</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> MyClass.prototype === <span class="hljs-string">&quot;object&quot;</span>); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p><code>class</code>構文のメソッド定義は、このプロトタイプオブジェクトのプロパティとして定義されます。</p>
<p>次のコードでは、クラスのメソッドがプロトタイプオブジェクトに定義されていることを確認できます。
また、クラスには<code>constructor</code>メソッド（コンストラクタ）が必ず定義されます。
この<code>constructor</code>メソッドもプロトタイプオブジェクトに定義されており、この<code>constructor</code>プロパティはクラス自身を参照します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> { }
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> MyClass.prototype.method === <span class="hljs-string">&quot;function&quot;</span>); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-comment">// クラス#constructorはクラス自身を参照する</span>
<span class="hljs-built_in">console</span>.log(MyClass.prototype.constructor === MyClass); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。</p>
<h2 id="prototype-chain"><a name="prototype-chain" class="plugin-anchor" href="#prototype-chain"><i class="fa fa-link" aria-hidden="true"></i></a>プロトタイプチェーン </h2>
<p><code>class</code>構文で定義したプロトタイプメソッドはプロトタイプオブジェクトに定義されます。
しかし、インスタンス（オブジェクト）にはメソッドが定義されていないのに、インスタンスからクラスのプロトタイプメソッドを呼び出せます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
instance.method(); <span class="hljs-comment">// &quot;プロトタイプのメソッド&quot;</span>
</code></pre>
<p>インスタンスからプロトタイプメソッドを呼び出せるのは<strong>プロトタイプチェーン</strong>と呼ばれる仕組みによるものです。
プロトタイプチェーンは2つの処理から成り立ちます。</p>
<ul>
<li>インスタンス作成時に、インスタンスの<code>[[Prototype]]</code>内部プロパティへプロトタイプオブジェクトの参照を保存する処理</li>
<li>インスタンスからプロパティ（またはメソッド）を参照するときに、<code>[[Prototype]]</code>内部プロパティまで探索する処理</li>
</ul>
<h3 id="write-prototype-chain"><a name="write-prototype-chain" class="plugin-anchor" href="#write-prototype-chain"><i class="fa fa-link" aria-hidden="true"></i></a>インスタンス作成とプロトタイプチェーン </h3>
<p>クラスから<code>new</code>演算子によってインスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。
このとき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの<code>[[Prototype]]</code>という内部プロパティに保存されます。</p>
<p><code>[[Prototype]]</code>内部プロパティはECMAScriptの仕様で定められた内部的な表現であるため、通常のプロパティのようにはアクセスできません。
ここでは説明のために、<code>[[プロパティ名]]</code>という書式でECMAScriptの仕様上に存在する内部プロパティを表現しています。</p>
<!-- textlint-disable ja-technical-writing/sentence-length -->
<p><code>[[Prototype]]</code>内部プロパティへプロパティのようにはアクセスできませんが、<code>Object.getPrototypeOf</code>メソッドで<code>[[Prototype]]</code>内部プロパティを参照できます。</p>
<!-- textlint-enable ja-technical-writing/sentence-length -->
<p>次のコードでは、<code>instance</code>オブジェクトの<code>[[Prototype]]</code>内部プロパティを取得しています。
その取得した結果がクラスのプロトタイプオブジェクトを参照していることを確認できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// `instance`の`[[Prototype]]`内部プロパティは`MyClass.prototype`と一致する</span>
<span class="hljs-keyword">const</span> MyClassPrototype = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);
<span class="hljs-built_in">console</span>.log(MyClassPrototype === MyClass.prototype); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。</p>
<h4 id="inner-property"><a name="inner-property" class="plugin-anchor" href="#inner-property"><i class="fa fa-link" aria-hidden="true"></i></a>[Note] <code>[[Prototype]]</code>内部プロパティを読み書きする </h4>
<p><code>Object.getPrototypeOf(オブジェクト)</code>で<code>オブジェクト</code>の<code>[[Prototype]]</code>を読み取ることができます。
一方、<code>Object.setPrototypeOf(オブジェクト, プロトタイプオブジェクト)</code>で<code>オブジェクト</code>の<code>[[Prototype]]</code>に<code>プロトタイプオブジェクト</code>を設定できます。
また、<code>[[Prototype]]</code>内部プロパティを通常のプロパティのように扱える<code>__proto__</code>という特殊なアクセッサプロパティが存在します。</p>
<p>しかし、これらの<code>[[Prototype]]</code>内部プロパティを直接読み書きすることは通常の用途では行いません。
また、既存のビルトインオブジェクトの動作なども変更できるため、不用意に扱うべきではないでしょう。</p>
<h3 id="read-prototype-chain"><a name="read-prototype-chain" class="plugin-anchor" href="#read-prototype-chain"><i class="fa fa-link" aria-hidden="true"></i></a>プロパティの参照とプロトタイプチェーン </h3>
<p>プロトタイプオブジェクトのプロパティがどのようにインスタンスから参照されるかを見ていきます。</p>
<p>オブジェクトのプロパティを参照するときに、オブジェクト自身がプロパティを持っていない場合でも、そこで探索が終わるわけではありません。
オブジェクトの<code>[[Prototype]]</code>内部プロパティ（仕様上の内部的なプロパティ）の参照先であるプロトタイプオブジェクトに対しても探索を続けます。
これは、スコープに指定した識別子の変数がなかった場合に外側のスコープへと探索するスコープチェーンと良く似た仕組みです。</p>
<p>つまり、オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。
すべてのオブジェクトにおいて見つからなかった場合の結果は<code>undefined</code>を返します。</p>
<ol>
<li><code>instance</code>オブジェクト自身</li>
<li><code>instance</code>オブジェクトの<code>[[Prototype]]</code>の参照先（プロトタイプオブジェクト）</li>
<li>どこにもなかった場合は<code>undefined</code></li>
</ol>
<p>次のコードでは、インスタンスオブジェクト自身は<code>method</code>プロパティを持っていません。
そのため、実際に参照しているのはクラスのプロトタイプオブジェクトの<code>method</code>プロパティです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// インスタンスには`method`プロパティがないため、プロトタイプオブジェクトの`method`が参照される</span>
instance.method(); <span class="hljs-comment">// &quot;プロトタイプのメソッド&quot;</span>
<span class="hljs-comment">// `instance.method`の参照はプロトタイプオブジェクトの`method`と一致する</span>
<span class="hljs-keyword">const</span> Prototype = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);
<span class="hljs-built_in">console</span>.log(instance.method === Prototype.method); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>このように、インスタンスオブジェクトに<code>method</code>が定義されていなくても、クラスのプロトタイプオブジェクトの<code>method</code>を呼び出すことができます。
このプロパティを参照する際に、オブジェクト自身から<code>[[Prototype]]</code>内部プロパティへと順番に探す仕組みのことを<strong>プロトタイプチェーン</strong>と呼びます。</p>
<p>プロトタイプチェーンの仕組みを疑似的なコードとして表現すると次のような動きをしています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// プロトタイプチェーンの動作の疑似的なコード</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// `instance.method()`を実行する場合</span>
<span class="hljs-comment">// 次のような呼び出し処理が行われている</span>
<span class="hljs-comment">// インスタンス自身が`method`プロパティを持っている場合</span>
<span class="hljs-keyword">if</span> (instance.hasOwnProperty(<span class="hljs-string">&quot;method&quot;</span>)) {
    instance.method();
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// インスタンスの`[[Prototype]]`の参照先（`MyClass`のプロトタイプオブジェクト）を取り出す</span>
    <span class="hljs-keyword">const</span> prototypeObject = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);
    <span class="hljs-comment">// プロトタイプオブジェクトが`method`プロパティを持っている場合</span>
    <span class="hljs-keyword">if</span> (prototypeObject.hasOwnProperty(<span class="hljs-string">&quot;method&quot;</span>)) {
        <span class="hljs-comment">// `this`はインスタンス自身を指定して呼び出す</span>
        prototypeObject.method.call(instance);
    }
}
</code></pre>
<p>プロトタイプチェーンの仕組みによって、プロトタイプオブジェクトに定義したプロトタイプメソッドをインスタンスから呼び出せます。</p>
<p>普段は、プロトタイプオブジェクトやプロトタイプチェーンといった仕組みを意識する必要はありません。
<code>class</code>構文はこのようなプロトタイプを意識せずにクラスを利用できるように導入された構文です。
しかし、プロトタイプベースである言語のJavaScriptではクラスをこのようなプロトタイプを使って表現していることは知っておくとよいでしょう。</p>
<!-- Note

インスタンスオブジェクトのメソッドがプロトタイプのメソッドの呼び出しの仕組みについてを見ていきます。

- プロトタイプチェーンという仕組み
- インスタンス化されるときに自動的にインスタンスはプロトタイプオブジェクトを参照する（継承）
- これは`[[Prototype]]`という内部プロパティに保存されますが、`__proto__`というアクセッサプロパティで参照できます
- しかし、`class`構文を利用する場合にはこれを意識して触ることはありません

-->
<h2 id="extends"><a name="extends" class="plugin-anchor" href="#extends"><i class="fa fa-link" aria-hidden="true"></i></a>継承 </h2>
<p><code>extends</code>キーワードを使うことで既存のクラスを継承できます。
継承とは、クラスの<strong>構造</strong>や<strong>機能</strong>を引き継いだ新しいクラスを定義することです。</p>
<h3 id="class-extends"><a name="class-extends" class="plugin-anchor" href="#class-extends"><i class="fa fa-link" aria-hidden="true"></i></a>継承したクラスの定義 </h3>
<p><code>extends</code>キーワードを使って既存のクラスを継承した新しいクラスを定義してみます。
<code>class</code>構文の右辺に<code>extends</code>キーワードで継承元となる<strong>親クラス</strong>（基底クラス）を指定することで、
親クラスを継承した<strong>子クラス</strong>（派生クラス）を定義できます。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> 子クラス <span class="hljs-keyword">extends</span> 親クラス </span>{

}
</code></pre>
<p>次のコードでは、<code>Parent</code>クラスを継承した<code>Child</code>クラスを定義しています。
子クラスである<code>Child</code>クラスのインスタンス化は通常のクラスと同じく<code>new</code>演算子を使って行います。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{

}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{

}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Child();
</code></pre>
<h3 id="class-super"><a name="class-super" class="plugin-anchor" href="#class-super"><i class="fa fa-link" aria-hidden="true"></i></a><code>super</code> </h3>
<p><code>extends</code>を使って定義した子クラスから親クラスを参照するには<code>super</code>というキーワードを利用します。
もっともシンプルな<code>super</code>を使う例としてコンストラクタの処理を見ていきます。</p>
<p><code>class</code>構文でも紹介しましたが、クラスは必ず<code>constructor</code>メソッド（コンストラクタ）を持ちます。
これは、継承した子クラスでも同じです。</p>
<!-- textlint-disable no-js-function-paren -->
<p>次のコードでは、<code>Parent</code>クラスを継承した<code>Child</code>クラスのコンストラクタで、<code>super()</code>を呼び出しています。
<code>super()</code>は子クラスから親クラスの<code>constructor</code>メソッドを呼び出します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 親クラス</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parentコンストラクタの処理&quot;</span>, ...args);
    }
}
<span class="hljs-comment">// Parentを継承したChildクラスの定義</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> {
        <span class="hljs-comment">// Parentのコンストラクタ処理を呼び出す</span>
        <span class="hljs-built_in">super</span>(...args);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Childコンストラクタの処理&quot;</span>, ...args);
    }
}
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&quot;引数1&quot;</span>, <span class="hljs-string">&quot;引数2&quot;</span>);
<span class="hljs-comment">// &quot;Parentコンストラクタの処理&quot;, &quot;引数1&quot;, &quot;引数2&quot;</span>
<span class="hljs-comment">// &quot;Childコンストラクタの処理&quot;, &quot;引数1&quot;, &quot;引数2&quot;</span>
</code></pre>
<p><code>class</code>構文でのクラス定義では、<code>constructor</code>メソッド（コンストラクタ）で何も処理しない場合は省略できることを紹介しました。
これは、継承した子クラスでも同じです。</p>
<p>次のコードの<code>Child</code>クラスのコンストラクタでは、何も処理を行っていません。
そのため、<code>Child</code>クラスの<code>constructor</code>メソッドの定義を省略できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{}
</code></pre>
<p>このように子クラスで<code>constructor</code>を省略した場合は次のように書いた場合と同じ意味になります。
<code>constructor</code>メソッドの引数をすべて受け取り、そのまま<code>super</code>へ引数の順番を維持して渡します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> {
        <span class="hljs-built_in">super</span>(...args); <span class="hljs-comment">// 親クラスに引数をそのまま渡す</span>
    }
}
</code></pre>
<h3 id="constructor-order"><a name="constructor-order" class="plugin-anchor" href="#constructor-order"><i class="fa fa-link" aria-hidden="true"></i></a>コンストラクタの処理順は親クラスから子クラスへ </h3>
<p>コンストラクタの処理順は、親クラスから子クラスへと順番が決まっています。</p>
<p><code>class</code>構文では必ず親クラスのコンストラクタ処理（<code>super()</code>の呼び出し）を先に行い、その次に子クラスのコンストラクタ処理を行います。
子クラスのコンストラクタでは、<code>this</code>を触る前に<code>super()</code>で親クラスのコンストラクタ処理を呼び出さないと<code>ReferenceError</code>となるためです。</p>
<p>次のコードでは、<code>Parent</code>と<code>Child</code>でそれぞれインスタンス（<code>this</code>）の<code>name</code>プロパティに値を書き込んでいます。
子クラスでは先に<code>super()</code>を呼び出してからでないと<code>this</code>を参照できません。
そのため、コンストラクタの処理順は<code>Parent</code>から<code>Child</code>という順番に限定されます。</p>
<!-- textlint-enable no-js-function-paren -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Parent&quot;</span>;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// 子クラスでは`super()`を`this`に触る前に呼び出さなければならない</span>
        <span class="hljs-built_in">super</span>();
        <span class="hljs-comment">// 子クラスのコンストラクタ処理</span>
        <span class="hljs-comment">// 親クラスで書き込まれた`name`は上書きされる</span>
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Child&quot;</span>;
    }
}
<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> Parent();
<span class="hljs-built_in">console</span>.log(parent.name); <span class="hljs-comment">// =&gt; &quot;Parent&quot;</span>
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child();
<span class="hljs-built_in">console</span>.log(child.name); <span class="hljs-comment">// =&gt; &quot;Child&quot;</span>
</code></pre>
<h3 id="prototype-inheritance"><a name="prototype-inheritance" class="plugin-anchor" href="#prototype-inheritance"><i class="fa fa-link" aria-hidden="true"></i></a>プロトタイプ継承 </h3>
<p>次のコードでは<code>extends</code>キーワードを使って<code>Parent</code>クラスを継承した<code>Child</code>クラスを定義しています。
<code>Parent</code>クラスでは<code>method</code>を定義しているため、これを継承している<code>Child</code>クラスのインスタンスからも呼び出せます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent#method&quot;</span>);
    }
}
<span class="hljs-comment">// `Parent`を継承した`Child`を定義</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-comment">// methodの定義はない</span>
}
<span class="hljs-comment">// `Child`のインスタンスは`Parent`のプロトタイプメソッドを継承している</span>
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Child();
instance.method(); <span class="hljs-comment">// &quot;Parent#method&quot;</span>
</code></pre>
<p>このように、子クラスのインスタンスから親クラスのプロトタイプメソッドもプロトタイプチェーンの仕組みによって呼び出せます。</p>
<p><code>extends</code>によって継承した場合、子クラスのプロトタイプオブジェクトの<code>[[Prototype]]</code>内部プロパティには親クラスのプロトタイプオブジェクトが設定されます。
このコードでは、<code>Child.prototype</code>オブジェクトの<code>[[Prototype]]</code>内部プロパティには<code>Parent.prototype</code>が設定されます。</p>
<p>これにより、プロパティを参照する場合には次のような順番でオブジェクトを探索しています。</p>
<ol>
<li><code>instance</code>オブジェクト自身</li>
<li><code>Child.prototype</code>（<code>instance</code>オブジェクトの<code>[[Prototype]]</code>の参照先）</li>
<li><code>Parent.prototype</code>（<code>Child.prototype</code>オブジェクトの<code>[[Prototype]]</code>の参照先）</li>
</ol>
<p>このプロトタイプチェーンの仕組みにより、<code>method</code>プロパティは<code>Parent.prototype</code>オブジェクトに定義されたものを参照します。</p>
<p>このようにJavaScriptでは<code>class</code>構文と<code>extends</code>キーワードを使うことでクラスの<strong>機能</strong>を継承できます。
<code>class</code>構文ではプロトタイプオブジェクトを参照する仕組みによって継承が行われています。
そのため、この継承の仕組みを<strong>プロトタイプ継承</strong>と呼びます。</p>
<h3 id="static-inheritance"><a name="static-inheritance" class="plugin-anchor" href="#static-inheritance"><i class="fa fa-link" aria-hidden="true"></i></a>静的メソッドの継承 </h3>
<p>インスタンスとクラスのプロトタイプオブジェクトとの間にはプロトタイプチェーンがあります。
クラス自身（クラスのコンストラクタ）も親クラス自身（親クラスのコンストラクタ）との間にプロトタイプチェーンがあります。</p>
<p>簡単に言えば、静的メソッドも継承されるということです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-built_in">console</span>.log(Child.hello()); <span class="hljs-comment">// =&gt; &quot;Hello&quot;</span>
</code></pre>
<p><code>extends</code>によって継承した場合、子クラスのコンストラクタの<code>[[Prototype]]</code>内部プロパティには親クラスのコンストラクタが設定されます。
このコードでは、<code>Child</code>コンストラクタの<code>[[Prototype]]</code>内部プロパティに<code>Parent</code>コンストラクタが設定されます。</p>
<p>つまり、先ほどのコードでは<code>Child.hello</code>プロパティを参照した場合には、次のような順番でオブジェクトを探索しています。</p>
<ol>
<li><code>Child</code>コンストラクタ</li>
<li><code>Parent</code>コンストラクタ（<code>Child</code>コンストラクタの<code>[[Prototype]]</code>の参照先）</li>
</ol>
<p>クラスのコンストラクタ同士にもプロトタイプチェーンの仕組みがあるため、子クラスは親クラスの静的メソッドを呼び出せます。</p>
<h3 id="super-property"><a name="super-property" class="plugin-anchor" href="#super-property"><i class="fa fa-link" aria-hidden="true"></i></a><code>super</code>プロパティ </h3>
<!-- textlint-disable no-js-function-paren -->
<p>子クラスから親クラスのコンストラクタ処理を呼び出すには<code>super()</code>を使います。
同じように、子クラスのプロトタイプメソッドからは、<code>super.プロパティ名</code>で親クラスのプロトタイプメソッドを参照できます。</p>
<p>次のコードでは、<code>Child#method</code>の中で<code>super.method()</code>と書くことで<code>Parent#method</code>を呼び出しています。
このように、子クラスから継承元の親クラスのプロトタイプメソッドは<code>super.プロパティ名</code>で参照できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent#method&quot;</span>);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child#method&quot;</span>);
        <span class="hljs-comment">// `this.method()`だと自分(`this`)のmethodを呼び出して無限ループする</span>
        <span class="hljs-comment">// そのため明示的に`super.method()`とParent#methodを呼び出す</span>
        <span class="hljs-built_in">super</span>.method();
    }
}
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child();
child.method();
<span class="hljs-comment">// コンソールには次のように出力される</span>
<span class="hljs-comment">// &quot;Child#method&quot;</span>
<span class="hljs-comment">// &quot;Parent#method&quot;</span>
</code></pre>
<p>プロトタイプチェーンでは、インスタンスからクラス、さらに親のクラスと継承関係をさかのぼるようにメソッドを探索すると紹介しました。
このコードでは<code>Child#method</code>が定義されているため、<code>child.method</code>は<code>Child#method</code>を呼び出します。
そして<code>Child#method</code>は<code>super.method</code>を呼び出しているため、<code>Parent#method</code>が呼び出されます。</p>
<p>クラスの静的メソッド同士も同じように<code>super.method()</code>と書くことで呼び出せます。
次のコードでは、<code>Parent</code>を継承した<code>Child</code>から親クラスの静的メソッドを呼び出しています。</p>
<!-- textlint-enable no-js-function-paren -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent.method&quot;</span>);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child.method&quot;</span>);
        <span class="hljs-comment">// `super.method()`で`Parent.method`を呼びだす</span>
        <span class="hljs-built_in">super</span>.method();
    }
}
Child.method();
<span class="hljs-comment">// コンソールには次のように出力される</span>
<span class="hljs-comment">// &quot;Child.method&quot;</span>
<span class="hljs-comment">// &quot;Parent.method&quot;</span>
</code></pre>
<h3 id="instanceof"><a name="instanceof" class="plugin-anchor" href="#instanceof"><i class="fa fa-link" aria-hidden="true"></i></a>継承の判定 </h3>
<p>あるクラスが指定したクラスをプロトタイプ継承しているかは<code>instanceof</code>演算子を使って判定できます。</p>
<p>次のコードでは、<code>Child</code>のインスタンスは<code>Child</code>クラスと<code>Parent</code>クラスを継承したオブジェクトであることを確認しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{}

<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> Parent();
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child();
<span class="hljs-comment">// `Parent`のインスタンスは`Parent`のみを継承したインスタンス</span>
<span class="hljs-built_in">console</span>.log(parent <span class="hljs-keyword">instanceof</span> Parent); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-built_in">console</span>.log(parent <span class="hljs-keyword">instanceof</span> Child); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// `Child`のインスタンスは`Child`と`Parent`を継承したインスタンス</span>
<span class="hljs-built_in">console</span>.log(child <span class="hljs-keyword">instanceof</span> Parent); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-built_in">console</span>.log(child <span class="hljs-keyword">instanceof</span> Child); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<!-- Note: instanceof演算子とは`[[Prototype]]`プロパティ

- `instanceof`演算子は`[[Prototype]]`プロパティを見ている
- <https://tc39.github.io/ecma262/#sec-ordinaryhasinstance>
- `Symbol.hasInstance`によって詳細は変わるため絶対とは言い切れない
- <https://tc39.github.io/ecma262/#sec-symbol.hasinstance>

-->
<p>より具体的な継承の使い方については「<a href="../../use-case/todoapp/">ユースケース:Todoアプリ</a>」の章で見ていきます。</p>
<h2 id="extends-built-in"><a name="extends-built-in" class="plugin-anchor" href="#extends-built-in"><i class="fa fa-link" aria-hidden="true"></i></a>ビルトインオブジェクトの継承 </h2>
<p>ここまで自身が定義したクラスを継承してきましたが、ビルトインオブジェクトのコンストラクタも継承できます。
ビルトインオブジェクトには<code>Array</code>、<code>String</code>、<code>Object</code>、<code>Number</code>、<code>Error</code>、<code>Date</code>などのコンストラクタがあります。
<code>class</code>構文ではこれらのビルトインオブジェクトを継承できます。</p>
<p>次のコードでは、ビルトインオブジェクトである<code>Array</code>を継承して独自のメソッドを加えた<code>MyArray</code>クラスを定義しています。
継承した<code>MyArray</code>は<code>Array</code>の性質であるメソッドや状態管理についての仕組みを継承しています。
継承した性質に加えて、<code>MyArray#first</code>や<code>MyArray#last</code>といったアクセッサプロパティを追加しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
    <span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[<span class="hljs-number">0</span>];
        }
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">last</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[<span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>];
        }
    }
}

<span class="hljs-comment">// Arrayを継承しているのでArray.fromも継承している</span>
<span class="hljs-comment">// Array.fromはIterableなオブジェクトから配列インスタンスを作成する</span>
<span class="hljs-keyword">const</span> array = MyArray.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-built_in">console</span>.log(array.length); <span class="hljs-comment">// =&gt; 5</span>
<span class="hljs-built_in">console</span>.log(array.first); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-built_in">console</span>.log(array.last); <span class="hljs-comment">// =&gt; 5</span>
</code></pre>
<p><code>Array</code>を継承した<code>MyArray</code>は、<code>Array</code>が元々持つ<code>length</code>プロパティや<code>Array.from</code>メソッドなどを継承しているので利用できます。</p>
<h2 id="conclusion"><a name="conclusion" class="plugin-anchor" href="#conclusion"><i class="fa fa-link" aria-hidden="true"></i></a>まとめ </h2>
<p>この章ではクラスについて学びました。</p>
<ul>
<li>JavaScriptのクラスはプロトタイプベース</li>
<li>クラスは<code>class</code>構文で定義できる</li>
<li>クラスで定義したメソッドはプロトタイプオブジェクトとプロトタイプチェーンの仕組みで呼び出せる</li>
<li>アクセッサプロパティはgetterとsetterのメソッドを定義することでプロパティのように振る舞う</li>
<li>クラスは<code>extends</code>で継承できる</li>
<li>クラスのプロトタイプメソッドと静的メソッドはどちらも継承される</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. <code>class</code>構文でしか実現できない機能はなく、読みやすさやわかりやさのために導入された構文という側面もあるため、JavaScriptの<code>class</code>構文は糖衣構文（シンタックスシュガー）と呼ばれることがあります。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>

                                
                                </section>
                            
                        </div>
                    </div>
                
<footer class="book_footer">
    <p>Copyright (c) 2016-present <a href="https://github.com/asciidwango/js-primer">jsprimer project</a></p>
</footer>

            </div>

            
                
                <a href="../function-this/" class="navigation navigation-prev " aria-label="Previous page: 関数とthis">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../error-try-catch/" class="navigation navigation-next " aria-label="Next page: 例外処理">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"author":"azu","description":"JavaScriptにおけるクラスの定義方法や継承方法を紹介します。プロトタイプベースの言語であるJavaScriptがどのように継承などを実現しているのかを紹介します。","title":"クラス","level":"1.3.20","depth":2,"next":{"title":"例外処理","level":"1.3.21","depth":2,"path":"basic/error-try-catch/README.md","ref":"./basic/error-try-catch/README.md","articles":[]},"previous":{"title":"関数とthis","level":"1.3.19","depth":2,"path":"basic/function-this/README.md","ref":"./basic/function-this/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-lunr","page-toc-button","include-codeblock","anchors","canonical-link","ga","js-console","github-issue-feedback"],"root":"./source/","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"docSearch":{"apiKey":"fd28ebaba94be0c39fb9fa1b2fed4f23","index":"asciidwango"},"github-issue-feedback":{"repo":"asciidwango/js-primer","label":"問題を報告する"},"fontsettings":{"theme":"white","family":"sans","size":2},"js-console":{},"canonical-link":{"baseURL":"https://jsprimer.net"},"highlight":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"ga":{"configuration":"auto","token":"UA-2184335-18"},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"./resources/gitbook-plugin-include-codeblock.hbs","theme":"chrome","unindent":false},"edit-link":{"base":"https://github.com/asciidwango/js-primer/edit/master/source/","label":"Edit"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"IPAexMincho","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"index.md","glossary":"GLOSSARY.md","summary":"README.md"},"variables":{"esversion":"2020","nodeversion":"14.15.0","npmversion":"6.14.8","triplebackticks":"```","console":"<a class=\"gitbook-plugin-js-console\" aria-hidden=\"true\"></a>"},"title":"JavaScript Primer #jsprimer","gitbook":">=3.0.0","description":"JavaScriptの基本的な書き方からアプリケーションの作成などのユースケースを学ぶための入門書です"},"file":{"path":"basic/class/README.md","mtime":"2021-05-30T10:01:48.918Z","type":"markdown"},"gitbook":{"version":"3.6.20","time":"2021-05-30T10:02:39.023Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-js-console/console-ui.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-github-issue-feedback/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

